<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>2025-ciscn | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="fffffhash观察题目是让我们输入一个hash后的值等于题目给的giao值。 观察hash函数，每次都是乘一个相同的数字后再与字节值异或，由于异或的值是一个小值，我们可以当作是加减一个值，这个值的大小不大于256，所以对于一个长度为n的字节串，他的hash值应该就满足下面这个式子：  base*(x^n+v_{n-1}*x^{n-1}+v_{n-2}*x^{n-2}+...+v_{1}*x+v">
<meta property="og:type" content="article">
<meta property="og:title" content="2025-ciscn">
<meta property="og:url" content="http://example.com/2025/01/14/2025-ciscn/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="fffffhash观察题目是让我们输入一个hash后的值等于题目给的giao值。 观察hash函数，每次都是乘一个相同的数字后再与字节值异或，由于异或的值是一个小值，我们可以当作是加减一个值，这个值的大小不大于256，所以对于一个长度为n的字节串，他的hash值应该就满足下面这个式子：  base*(x^n+v_{n-1}*x^{n-1}+v_{n-2}*x^{n-2}+...+v_{1}*x+v">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-01-14T02:00:56.000Z">
<meta property="article:modified_time" content="2025-01-14T02:06:08.438Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2025-ciscn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/14/2025-ciscn/" class="article-date">
  <time class="dt-published" datetime="2025-01-14T02:00:56.000Z" itemprop="datePublished">2025-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      2025-ciscn
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="fffffhash"><a href="#fffffhash" class="headerlink" title="fffffhash"></a>fffffhash</h1><p>观察题目是让我们输入一个hash后的值等于题目给的giao值。</p>
<p>观察hash函数，每次都是乘一个相同的数字后再与字节值异或，由于异或的值是一个小值，我们可以当作是加减一个值，这个值的大小不大于256，所以对于一个长度为n的字节串，他的hash值应该就满足下面这个式子：</p>
<script type="math/tex; mode=display">
base*(x^n+v_{n-1}*x^{n-1}+v_{n-2}*x^{n-2}+...+v_{1}*x+v_0)(modMOD)</script><p>对于这个式子我们就可以使用格规约的方法进行攻击，测试第一个规约出来的值长度为16</p>
<p>这个题也可以使用中间相遇攻击的方法进行攻击，可以尝试一下，这里就不给出了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from sage.all import *</span><br><span class="line">MOD = 2**128</span><br><span class="line">t=16</span><br><span class="line">PR = PolynomialRing(Zmod(MOD), t, names=&#x27;x&#x27;)</span><br><span class="line">xx = [PR.gen(i) for i in range(t)]</span><br><span class="line">base_num = 0x6C62272E07BB014262B821756295C58D</span><br><span class="line">x = 0x0000000001000000000000000000013B</span><br><span class="line">giao=201431453607244229943761366749810895688</span><br><span class="line">for i in range(t):</span><br><span class="line">    base_num = base_num * x</span><br><span class="line">    base_num =base_num+xx[i]</span><br><span class="line">f=base_num-giao</span><br><span class="line">coe=f.coefficients()</span><br><span class="line">M=matrix(ZZ,t+2,t+2)</span><br><span class="line">for i in range(t):</span><br><span class="line">    M[i,i]=1</span><br><span class="line">M[t,t]=256</span><br><span class="line">for i in range(t+1):</span><br><span class="line">    M[i,-1]=coe[i]</span><br><span class="line">M[-1,-1]=MOD</span><br><span class="line">H=M.LLL()</span><br><span class="line">for i in H:</span><br><span class="line">    if(256 in i):</span><br><span class="line">        res=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">base_num = 0x6c62272e07bb014262b821756295c58d</span><br><span class="line">x = 0x0000000001000000000000000000013b</span><br><span class="line">MOD = 2**128</span><br><span class="line">flag=[]</span><br><span class="line">for i in range(len(res)):</span><br><span class="line">    base_num = (base_num * x) &amp; (MOD - 1) </span><br><span class="line">    for k in range(256):</span><br><span class="line">        if((base_num^k)-base_num==res[i]):</span><br><span class="line">            base_num ^=k</span><br><span class="line">            flag.append(k)</span><br><span class="line">            break</span><br><span class="line">ss=&#x27;&#x27;</span><br><span class="line">for i in flag:</span><br><span class="line">    ss+=hex(i)[2:].zfill(2)</span><br><span class="line">print(ss)</span><br></pre></td></tr></table></figure>
<h1 id="rasnd"><a href="#rasnd" class="headerlink" title="rasnd"></a>rasnd</h1><p>对于第一个部分的flag</p>
<p>我们观察题目给的两个式子</p>
<script type="math/tex; mode=display">
hint1=x1*p+y1*q-0x114\\
    hint2=x2*p+y2*q-0x514</script><p>x是11bit，y是114和514bit，由于x比较小，其实我们是可以通过遍历的方式求得x，可以把$x_1,x_2$当作一个已知量，题目就已经很清晰了，把p约掉后剩下q再与n做gcd即可分解n了。</p>
<p>对于第二个部分的flag</p>
<script type="math/tex; mode=display">
(514*p - 114*q )^{n - p - q}=(514*p - 114*q ) (modn)</script><p>所以直接联立方程组即可求出p,q还原明文，整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from tqdm import *</span><br><span class="line">import math</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from sage.all import *</span><br><span class="line">n=15428378682808047369729539612849773977351266907005249848551927745179589793201094228559121175032737955878647870160177160397245988513653262495752422128908799243256506605455757248368872726223873708635139946850304152435502570141379286853985364541354685264122339662762441747372478895242822893933897462705436998125064994343778026334193014741078794234731029543321503363519697567486316749015392604019903565484166338202778119436114878787666820006192734321442574905682701228037779919642807430553465725881974172731400277846697398837064840194185750356843931240280984419631010218867389259679817956941531563720176489959565536188397</span><br><span class="line">c=12311541499004604200236916499349205846427096674314588086510631788926072078719351448646169918289109610507742992745781039518728731071967436965061884458130326005168245432412279626906101863478338683877895019784422395240860608685913496357594241053186169697293064446273562113197595287624822079722824077054648562740537822534033140390319787295623650383968704875832547313466734377262050704021334193507275258922262660647824318306838104067714316000286869379693942751129882040996725977381520370180207186392901674104709320401895811780418145615330784795101228750698014242817456836562876899931370268409067660675018643871717227313658</span><br><span class="line">hint1=1642169733436771135664520656142188761411845959348096784398376090505380052495290097851697457504611854584152629529425307316772033432534375461053077627455193773130301015652592603250376477669193772833357092836311168720444956930063724726061060140962165091692267031606422347042905067658647729884255199407653433190610665322919179561630336761190467365</span><br><span class="line">hint2=5551747138618727171773321575791733273076756615723885567436415904604966959458490277318362541649129337808802118926493262634763937750210378053453527713899901774935433023207535935321843155751766422374491886434532618700040108440935479135753975555403376309454682833100109181877266998543543846909295860103484771406415217260109315235129296658055184813958169218495709245196271855267640622190375062939285960112201873430002149251649679935167927817626331832294069313328206778</span><br><span class="line">hint1=hint1+0x114</span><br><span class="line">hint2=hint2+0x514</span><br><span class="line">def getp(hint1,hint2,n):</span><br><span class="line">    for x1 in trange(1,2**11):</span><br><span class="line">        for x2 in range(1,2**11):</span><br><span class="line">            p=math.gcd(hint2*x1-hint1*x2,n)</span><br><span class="line">            if(p!=1):</span><br><span class="line">                return p</span><br><span class="line">p=getp(hint1,hint2,n)</span><br><span class="line">q=n//p</span><br><span class="line">e = 0x10001</span><br><span class="line">d=inverse(e,(p-1)*(q-1))</span><br><span class="line">flag=b&#x27;&#x27;</span><br><span class="line">flag+=long_to_bytes(int(pow(c,d,n)))</span><br><span class="line">n=27304780849694423339383484977186266330389425646528065625497565745795638648828062639473996623588698762753146235151108126420977796844428501160763319666798715218447902834612303735177872027008920401294357482031854938125709140433065827081300839613511804160316491491031632730824994184914234660446289671804022045677787702098863099539651943453926045087901898426244698413091456344802150260007283612823928043655412081343588031466645814347820061064753335412269236089640592319528756769313451596405487571315468336477244984077644293384871690534279543863484767904901210496058795440596942630968255014984731155489864246840234667001417</span><br><span class="line">c=15345714434074055292694048806935544270153104021609550824876952306034067479894701698573290606861629285414856546362924472951947263518612748639904603022632760447886103691397382763388218549691497957562969398205996016066835482973092125604584119551351190484227333681302207328483167508461378264653318581823728471816676463601178380020697690176558636427767120185430857580427504967241695510761471224004993094661089353253222240299229409715246243046129930003638405080254505248363707962924419789835146265839618520569141805792060381649038337877178822148975540522056612034461760014474075882340504541481513970630835462554235470346475</span><br><span class="line">hint1=17602174385973044814178733507403094284745791129903364104533711640443330458579716563753178246981073542692332433844902742118325919571150280367606023196267358245762199293741825875527085813095646769963953826540824744879337001014346793390335985309617368648336161014893966160872805800912168191899742324853272847938704487420436610804168779631219370534647095461154552565485779033131497101303042725461524799298270217450073396092439394777919860949842498974276505857076208386972099387042756791993606329357195903926533712694571189872758863613002801173053427969910237331140104634532523474080106045440196525334795994605760965286097</span><br><span class="line">var(&#x27;p,q&#x27;)</span><br><span class="line">c1=inverse(hint1,n)</span><br><span class="line">f=514*p - 114*q-c1</span><br><span class="line">g=p * q-n</span><br><span class="line">print(solve([f,g],[p,q]))</span><br><span class="line">p=160247203535926288327472656601878781443989033826771766955734470318827419391305327872790796496428041845814802384723559871289959299088000887848984637610216098983438408353121194529852283540070441367798473737141676032568377447595601130840102873781251017230839516821654257824215338216643049472594309958707439106441</span><br><span class="line">q=170391621489812050399712037637431632018509218121185391060891105777675416473171049932716729939354748557973484195449133496291238596503578305511179199378536936739711381230517911177551655316019732468100928430291180811640657984776088247830397489245305174528823256517954781339979951279712313196947494726049133459137</span><br><span class="line">d=inverse(e,(p-1)*(q-1))</span><br><span class="line">print(flag+long_to_bytes(int(pow(c,d,n))))</span><br><span class="line">#flag&#123;edd3d199-1b37-47ff-94dc-05628985f54d&#125;</span><br></pre></td></tr></table></figure>
<h1 id="lwewl"><a href="#lwewl" class="headerlink" title="lwewl"></a>lwewl</h1><p>对于flag的第一部分</p>
<p>已知$const<em>K_1,const</em>K_2+m+e *257 $</p>
<p>​        我们需要还原m，对于第二个式子，如果我们能求出$const<em>K_2$后，然后由于m是小于257的，所以对于整体模257后，我们就可以消除噪声的干扰，然后还原m。所以问题就转换为求$const$，$K_1$是一个$612</em>512$的矩阵，$const$是一个$1*612$的向量，直接对$K_1$进行求解是解不出来的，因为未知数大于方程的数量，所以考虑格的方法。</p>
<p>​        本题直接构造格是算不出来的，是一个1125维的格，需要使用flatter进行加速，但是格出来后也无法得到我们想要的向量，需要使用其他的方法。</p>
<p>​        因为前面我们使用solve_left可以求解出一个512长度的向量，然后后面是100个零，对于$K_1$最后的100行我们可以用前面的512行线性表示，$K_{1,i}=K_1,i,i\in[0,511],K_{1,i}=\sum_{i=0}^{511}x_{i,j}*K_{1,j},i\in[512,611]$</p>
<p>所以说我们前面使用solve_left求出来的解$cfake_i=k_i+\sum_{j=512}^{611}k_j<em>x_{i,j}(modq)=&gt;-k_i=-cfake_i+\sum_{j=512}^{611}k_j</em>x_{i,j}(modq)$</p>
<p>对于上面的$k_i$使用格的方式进行求解</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 && \cdots & &&x_{0,0} & x_{1,0} & \cdots & x_{99,0} \\
 &1& \cdots & &&x_{0,1} & x_{1,1} & \cdots & x_{99,1} \\
\vdots&\vdots &&& & \vdots & \vdots & & \vdots \\
 &&\cdots& 1& & x_{0,99} & x_{1,99} & \cdots & x_{99,99} \\
& &\cdots&&1 & \text{cfake}_0 & \text{cfake}_1 & \cdots & \text{cfake}_{99} \\
&&&&&q&&&\\&&&&&&q&&\\&&&&&&&\ddots\\&&&&&&&&q
\end{bmatrix}</script><p>格出来的最短向量就是后面的$K_1$前面512位代入方程即可，然后判断一下正负号即可还原const，从而解出flag的第一部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from sage.all import *</span><br><span class="line">from re import findall</span><br><span class="line">from subprocess import check_output</span><br><span class="line">from tqdm import *</span><br><span class="line">def flatter(M):</span><br><span class="line">    # compile https://github.com/keeganryan/flatter and put it in $PATH</span><br><span class="line">    z = &quot;[[&quot; + &quot;]\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot;</span><br><span class="line">    ret = check_output([&quot;flatter&quot;], input=z.encode())</span><br><span class="line">    return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\d+&quot;, ret)))</span><br><span class="line">def decrypt(const, lwe_pubkey2, enc):</span><br><span class="line">    return (int(enc)-int(const * vector(GF(lwe_ciphertext_modulus), lwe_pubkey2)))%lwe_plaintext_modulus</span><br><span class="line"></span><br><span class="line">n = 512</span><br><span class="line">m = n + 100</span><br><span class="line">p = 257</span><br><span class="line">q = next_prime(1048576)</span><br><span class="line">c1,c2=load(&#x27;/home/martin/code/task3/lwe_ciphertext.sobj&#x27;)</span><br><span class="line">k1,k2=load(&#x27;/home/martin/code/task3/lwe_public_key.sobj&#x27;)</span><br><span class="line">pk_A=Matrix(GF(q),k1)</span><br><span class="line">pk_b=Matrix(GF(q),k2)</span><br><span class="line">encrypt_A=c1</span><br><span class="line">encrypt_b=c2</span><br><span class="line"></span><br><span class="line">def pk_Aexpress(pk_A):</span><br><span class="line">    pkA_1 = pk_A[:512,:]</span><br><span class="line">    pkA_2 = pk_A[512:,:]</span><br><span class="line">    ks = []</span><br><span class="line">    for row in pkA_2:</span><br><span class="line">        ks.append(pkA_1.solve_left(row))</span><br><span class="line">    return Matrix(ZZ,ks)</span><br><span class="line"></span><br><span class="line">def fuck(A,pk_A):</span><br><span class="line">    c_tmp = pk_A.solve_left(A)[:-100]</span><br><span class="line">    tmpks = pk_Aexpress(pk_A)</span><br><span class="line">    ks = tmpks[:,:100]</span><br><span class="line">    ks = ks.stack(Matrix(ZZ,[c_tmp[:100]]))</span><br><span class="line">    M = Matrix(ZZ,100 + 100 + 1,100 + 100 + 1)</span><br><span class="line">    M[:101,:101] = identity_matrix(101)  </span><br><span class="line">    M[:101,101:] = ks[:,:100]</span><br><span class="line">    M[101:,101:] = q * identity_matrix(100)</span><br><span class="line">    ML = flatter(M)</span><br><span class="line">    rows = ML[0]</span><br><span class="line">    c_new = [0 for i in range(612)]</span><br><span class="line">    c_list = Matrix(ZZ,Matrix(GF(q),rows[:100]*tmpks) + Integer(rows[100]) * Matrix(GF(q),c_tmp))[0]</span><br><span class="line">    for _ in range(512):</span><br><span class="line">        if c_list[_] == q-1:</span><br><span class="line">            c_new[_] = -1</span><br><span class="line">        else:</span><br><span class="line">            c_new[_] = int(c_list[_])</span><br><span class="line">    for _ in range(100):</span><br><span class="line">        if rows[_] == q-1:</span><br><span class="line">            c_new[_+512] = -1</span><br><span class="line">        else:</span><br><span class="line">            c_new[_+512] = int(rows[_])</span><br><span class="line"></span><br><span class="line">    return c_new</span><br><span class="line"></span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">for _ in trange(len(encrypt_A)):</span><br><span class="line">    A = vector(GF(q),encrypt_A[_])</span><br><span class="line">    b = encrypt_b[_]</span><br><span class="line">    c_new = fuck(A,pk_A)</span><br><span class="line"></span><br><span class="line">    c_first = c_new[:512]</span><br><span class="line">    c_secon = c_new[512:]</span><br><span class="line"></span><br><span class="line">    c = vector(ZZ, c_first+c_secon)</span><br><span class="line">    if c*pk_A != A:</span><br><span class="line">        c_first = [-i for i in c_first]</span><br><span class="line">        c = vector(ZZ, c_first+c_secon)</span><br><span class="line"></span><br><span class="line">    if c*pk_A != A:</span><br><span class="line">        c_first = [-i for i in c_first]</span><br><span class="line">        c_secon = [-i for i in c_secon]</span><br><span class="line">        c = vector(ZZ, c_first+c_secon)</span><br><span class="line"></span><br><span class="line">    if c*pk_A != A:</span><br><span class="line">        c_first = [-i for i in c_first]</span><br><span class="line">        c = vector(ZZ, c_first+c_secon)</span><br><span class="line">    # print(c*pk_A == A)</span><br><span class="line">    s=vector(GF(q),c)</span><br><span class="line">    flag+=chr(decrypt(s,k2,encrypt_b[_]))</span><br><span class="line">print(flag)</span><br><span class="line">#a3bc5491-fa53-4f47</span><br></pre></td></tr></table></figure>
<p>另一种解法：</p>
<p>​    我们其实不需要求出const，我们需要求的是$const<em>K_2$，已知$const</em>K_1$，所以我们其实可以只需要求出一个矩阵S使得$K_1*S=K_2$即可，攻击代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">K1 = matrix(ZZ, k1)</span><br><span class="line">K2 = vector(ZZ, k2)</span><br><span class="line">K1r = K1.change_ring(RDF)</span><br><span class="line">K2r = K2.change_ring(RDF)</span><br><span class="line">sk = K1r.solve_right(K2r)</span><br><span class="line">sk = vector(GF(lwe_ciphertext_modulus), [round(x) for x in sk])</span><br><span class="line">flag = []</span><br><span class="line"></span><br><span class="line">for tmp1, tmp2 in zip(*lwe_ciphertext):</span><br><span class="line">    T1 = vector(GF(lwe_ciphertext_modulus), tmp1)</span><br><span class="line">    m = ZZ(tmp2 - T1 * sk)</span><br><span class="line">    if m &gt;= lwe_ciphertext_modulus // 2:</span><br><span class="line">        m -= lwe_ciphertext_modulus</span><br><span class="line">    m = m % lwe_plaintext_modulus</span><br><span class="line">    flag1.append(m)</span><br><span class="line">print(bytes(flag1))</span><br></pre></td></tr></table></figure>
<p>​    对于flag的第二部分</p>
<p>​    这个是在一个RLWE问题，在商环f下我们有$b = a * s + e$，e就是一个噪声，所以对于这个题思路很简单就是构造一个关于a,b的格直接格规约即可，但是由于是在商环上进行的，我们需要处理多项式的乘法和模就可以成功构造格，还原flag了。</p>
<p>​    首先是多项式的乘法</p>
<script type="math/tex; mode=display">(a_0,a_1,...,a_{n-1})*\begin{bmatrix}
b_0&b_1&b_2&\cdots&b_{n-1}&&&&\\&b_0&b_1&\cdots&b_{n-2}&b_{n-1}\\&&b_0&\cdots&b_{n-3}&b_{n-2}&b_{n-1}\\&&&\ddots&\vdots&\vdots&\vdots&\ddots\\
&&&&b_0&b_1&b_2&\cdots&b_{n-1}\end{bmatrix}=(d_0,d_1,...,d_{2n-2})</script><p>然后我们就需要对向量d进行模f然后得到我们最后的多项式c</p>
<p>然后是多项式的模运算，首先对于小于n次的直接写即可，所以我们只需要计算d中大于n次的每一个系数，对于$x^n=-(v_{n-1}x^{n-1}+v_{n-2}x^{n-2}+…+v_1x+v_0)(modf)$，然后对于$x^{n+1}$其实就是上面的式子整体乘一个$x$，然后式子就变成了$x^{n+1}=-(v_{n-1}x^{n}+v_{n-2}x^{n-1}+…+v_1x^2+v_0x)(modf)$，而这个式子中的$x^n$我们可以使用第一个式子$x^n$来进行替换，也就可以得到$x^{n+1}$在$modf$下的系数，同理也可以递推出剩下的。</p>
<p>然后我们就可以得到求模运算的矩阵</p>
<script type="math/tex; mode=display">(d_0,d_1,...,d_{2n-2})\begin{bmatrix}1\\&1\\&&1\\&&&\ddots\\&&&&1\\v_{0,0}&r_{0,1}&r_{0,2}&\cdots&r_{0,n-1}\\v_{1,0}&r_{1,1}&r_{1,2}&\cdots&r_{1,n-1}\\\vdots&\vdots&\vdots&\vdots&\vdots&\\v_{n-1,0}&r_{n-1,1}&r_{n-1,2}&\cdots&r_{n-1,n-1}
\end{bmatrix}=(c_0,c_1,...,c_{n-1})</script><p>所以对矩阵</p>
<p>$L=\begin{bmatrix}<br>b_0&amp;b_1&amp;b_2&amp;\cdots&amp;b_{n-1}&amp;&amp;&amp;&amp;\\&amp;b_0&amp;b_1&amp;\cdots&amp;b_{n-2}&amp;b_{n-1}\\&amp;&amp;b_0&amp;\cdots&amp;b_{n-3}&amp;b_{n-2}&amp;b_{n-1}\\&amp;&amp;&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\<br>&amp;&amp;&amp;&amp;b_0&amp;b_1&amp;b_2&amp;\cdots&amp;b_{n-1}\end{bmatrix}*\begin{bmatrix}1\\&amp;1\\&amp;&amp;1\\&amp;&amp;&amp;\ddots\\&amp;&amp;&amp;&amp;1\\v_{0,0}&amp;r_{0,1}&amp;r_{0,2}&amp;\cdots&amp;r_{0,n-1}\\v_{1,0}&amp;r_{1,1}&amp;r_{1,2}&amp;\cdots&amp;r_{1,n-1}\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\\v_{n-1,0}&amp;r_{n-1,1}&amp;r_{n-1,2}&amp;\cdots&amp;r_{n-1,n-1}<br>\end{bmatrix}$</p>
<p>进行格规约即可得到向量a，也就还原flag了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from sage.all import *</span><br><span class="line">from re import findall</span><br><span class="line">from subprocess import check_output</span><br><span class="line">def flatter(M):</span><br><span class="line">    # compile https://github.com/keeganryan/flatter and put it in $PATH</span><br><span class="line">    z = &quot;[[&quot; + &quot;]\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot;</span><br><span class="line">    ret = check_output([&quot;flatter&quot;], input=z.encode())</span><br><span class="line">    return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\d+&quot;, ret)))</span><br><span class="line">a, b, f, rlwe_modulus=load(&#x27;/home/martin/code/task3/rlwe_ciphertext.sobj&#x27;)</span><br><span class="line">n = 64</span><br><span class="line">A = a</span><br><span class="line">B = b.list()</span><br><span class="line">p = rlwe_modulus</span><br><span class="line">def construct_poly_mul_mat(n,v,b):</span><br><span class="line">    assert v[-1] == 1</span><br><span class="line">    mat1 = Matrix(ZZ,n,2*n-1)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            mat1[i,j+i] = b[j] </span><br><span class="line">    mat2 = Matrix(ZZ,2*n-1,n)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        mat2[i,i] = 1</span><br><span class="line">    for i in range(n,2*n-1):</span><br><span class="line">        for j in range(i-n,n):</span><br><span class="line">            mat2[i,j] = -v[j-(i-n)]</span><br><span class="line">        </span><br><span class="line">        init_row = vector(ZZ,n*[0])</span><br><span class="line">        for j in range(i-n):</span><br><span class="line">            temp = -v[n-1-j]*vector(ZZ,mat2[i-j-1])</span><br><span class="line">            init_row += temp</span><br><span class="line">        for j in range(n):</span><br><span class="line">            mat2[i,j] += init_row[j]   </span><br><span class="line">    return(mat1*mat2)</span><br><span class="line"></span><br><span class="line">v = f.list()</span><br><span class="line">poly_mul_mat = construct_poly_mul_mat(n,v,A)</span><br><span class="line"></span><br><span class="line">I = identity_matrix(n)</span><br><span class="line">B_mat = Matrix(ZZ,B)</span><br><span class="line">O = diagonal_matrix([0]*n)</span><br><span class="line">O_vec = Matrix(ZZ,1,n)</span><br><span class="line">O_vec_T = Matrix(ZZ,n,1)</span><br><span class="line">L = block_matrix(ZZ,[[p*I,O,0],[poly_mul_mat,I,O_vec_T],[B_mat,O_vec,1]])</span><br><span class="line"></span><br><span class="line">res = flatter(L)[0]</span><br><span class="line"></span><br><span class="line">s = res[n:2*n]</span><br><span class="line">for i in s:</span><br><span class="line">    print(chr(abs(i)),end = &quot;&quot;)</span><br><span class="line">#-8819-856a8fe5ada0</span><br><span class="line">#flag&#123;a3bc5491-fa53-4f47-8819-856a8fe5ada0&#125;</span><br></pre></td></tr></table></figure>
<h1 id="babypqc"><a href="#babypqc" class="headerlink" title="babypqc"></a>babypqc</h1><p>​        这个题有个很简单的非预期，就是其实整个题只需要考虑最后的answer==num，而我们的num题目原意是通过MT19937进行预测后，进行正确次数的验签成功后获得flag，因此还需要多次交互使得answer刚好为1时才可以成功，但是既然我们都可以多次交互使得answer为1了，实际上也就可以使得answer为0，$\frac{1}{16}$的概率，所以多次交互后就可以获得flag了。</p>
<p>​        非预期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">cnt = 0</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cnt += 1</span><br><span class="line">    print(f&#x27;Try #&#123;cnt&#125;&#x27;)</span><br><span class="line">    r = remote(&#x27;node1.anna.nssctf.cn&#x27;, &#x27;28975&#x27;)</span><br><span class="line">    r.sendline(&#x27;0&#x27;)</span><br><span class="line">    r.sendline(&#x27;[]&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;hex format!&#x27;)</span><br><span class="line">    r.interactive()</span><br><span class="line">    r.close()</span><br></pre></td></tr></table></figure>
<p>​        我的解法：</p>
<p>​        先求解MT19937，发现p+q+d的所有bit刚好满足MT19937的预测bit数量，所以我们需要通过N还原所有的p,q,d，将式子展开，我们会发现后面的N</p>
<script type="math/tex; mode=display">
N_i=(p+d_i)*(q+d_i)=p*q+d_i(p+q)+d_i^2=N_0+d_i(p+q)+d_i^2,i\in[1,25]\\
d_i(p+q)+d_i^2=N_i-N_0\\</script><p>最后这个式子其实就是一个AGCD问题，可以使用格规约的方法。</p>
<p>构造格</p>
<script type="math/tex; mode=display">
\begin{bmatrix}2^\rho&x2&x3&\cdots&x25\\&-x1&&\cdots&\\&&-x1&\cdots\\&&&\ddots\\&&&&-x1
\end{bmatrix},\rho=d_i^2的比特数,x_i=N_i-N_0,i\in[1,25]</script><p>攻击代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">res=[]</span><br><span class="line">for i in range(1,26):</span><br><span class="line">    res.append(N[i]-N[0])</span><br><span class="line">m=matrix(ZZ,25,25)</span><br><span class="line">for i in range(1,25):</span><br><span class="line">    m[0,i]=res[i]</span><br><span class="line">    m[i,i]=-res[0]</span><br><span class="line">m[0,0]=2**(704*2)</span><br><span class="line">H=m.LLL()</span><br><span class="line">for i in H:</span><br><span class="line">    if(i[0]%2**(704*2)==0):</span><br><span class="line">        d=i[0]//(2**(704*2))</span><br><span class="line">        if(res[0]%d==0):</span><br><span class="line">            d=abs(d)</span><br><span class="line">            pq=(res[0]//d-d)</span><br><span class="line">            print(pq)</span><br><span class="line">            break</span><br><span class="line">var(&#x27;p q&#x27;)</span><br><span class="line">f=p*q-N[0]</span><br><span class="line">g=p+q-pq</span><br><span class="line">solution=solve([f,g],[p,q])</span><br><span class="line">#p,q</span><br><span class="line">p=p&gt;&gt;282</span><br><span class="line">q=q&gt;&gt;282</span><br><span class="line">d=[]</span><br><span class="line">for i in res:</span><br><span class="line">    d.append(iroot(i%pq,2)[0])</span><br></pre></td></tr></table></figure>
<p>还原p,q,d后我们可以成功拿到满足MT19937的攻击要求的比特数量，使用extend_mt19937_predictor库可以预测已知比特的前后的随机数<a target="_blank" rel="noopener" href="https://github.com/NonupleBroken/ExtendMT19937Predictor">https://github.com/NonupleBroken/ExtendMT19937Predictor</a></p>
<p>一开始我还在考虑我可以预测出tmp的所有值，是否可以通过</p>
<script type="math/tex; mode=display">
s_1*tmp_1=H_1\\s_2*tmp_2=H_2</script><p>就像task3中使用格的方法进行规约，但是我们只有625个方程，但是需要求出1024长度的向量，向量中的值在$[-2,2]$之间，比task3的条件苛刻了很多，实操后也并没有规约出正确的向量，所以考虑是否有什么信息没有考虑到。这个时候我看到后面有个让我输入m然后会返回一个关于m的签名值，我的第一反应是可能在m签名中会涉及到$s_1,s_2$的一些关系可以进行攻击，查看c语言的源码有点困难，遂放弃。随后突然想起题目最后是让我实现系统中一开始给出的m的签名值，而我们是可以在输入m时之前就可以获得系统的m签名了，所以我们并不需要还原$s_1,s_2$。</p>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">from random import getrandbits</span><br><span class="line">from sage.all import *</span><br><span class="line">from pwn import *</span><br><span class="line">from gmpy2 import iroot</span><br><span class="line">from extend_mt19937_predictor import ExtendMT19937Predictor</span><br><span class="line">from re import findall</span><br><span class="line">from subprocess import check_output</span><br><span class="line">def flatter(M):</span><br><span class="line">    # compile https://github.com/keeganryan/flatter and put it in $PATH</span><br><span class="line">    z = &quot;[[&quot; + &quot;]\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot;</span><br><span class="line">    ret = check_output([&quot;flatter&quot;], input=z.encode())</span><br><span class="line">    return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\d+&quot;, ret)))</span><br><span class="line">while(1):</span><br><span class="line">    r = remote(&#x27;&#x27;, &#x27;&#x27;)</span><br><span class="line">    s=r.recvuntil(b&#x27;N = &#x27;)</span><br><span class="line">    N=eval(r.recvuntil(b&#x27;]&#x27;).decode())</span><br><span class="line">    res=[]</span><br><span class="line">    for i in range(1,26):</span><br><span class="line">        res.append(N[i]-N[0])</span><br><span class="line">    m=matrix(ZZ,25,25)</span><br><span class="line">    for i in range(1,25):</span><br><span class="line">        m[0,i]=res[i]</span><br><span class="line">        m[i,i]=-res[0]</span><br><span class="line">    m[0,0]=2**(704*2)</span><br><span class="line">    H=flatter(m)</span><br><span class="line">    for i in H:</span><br><span class="line">        if(i[0]%2**(704*2)==0):</span><br><span class="line">            d=i[0]//(2**(704*2))</span><br><span class="line">            if(res[0]%d==0):</span><br><span class="line">                d=abs(d)</span><br><span class="line">                pq=(res[0]//d-d)</span><br><span class="line">                break</span><br><span class="line">    p,q=var(&#x27;p,q&#x27;)</span><br><span class="line">    f=p*q-N[0]</span><br><span class="line">    g=p+q-pq</span><br><span class="line">    solution=solve([f,g],[p,q])</span><br><span class="line">    s=str(solution[0]).split(&#x27;==&#x27;)</span><br><span class="line">    p=eval(s[1].split(&#x27;,&#x27;)[0])</span><br><span class="line">    q=eval(s[2].split(&#x27;]&#x27;)[0])</span><br><span class="line">    p=p&gt;&gt;282</span><br><span class="line">    q=q&gt;&gt;282</span><br><span class="line">    d=[]</span><br><span class="line">    print(&#x27;getpq!!&#x27;)</span><br><span class="line">    for i in res:</span><br><span class="line">        d.append(iroot(i%pq,2)[0])</span><br><span class="line">    rc = ExtendMT19937Predictor()</span><br><span class="line">    sub=&#x27;&#x27;</span><br><span class="line">    sub+=bin(p)[2:].zfill(1184)</span><br><span class="line">    sub+=bin(q)[2:].zfill(1184)</span><br><span class="line">    for i in d:</span><br><span class="line">        sub+=bin(i)[2:].zfill(704)</span><br><span class="line">    for i in range(78):</span><br><span class="line">        c=int(sub[i:i+256],2)</span><br><span class="line">        rc.setrandbits(c,256)</span><br><span class="line">    for _ in range(78):</span><br><span class="line">        s=rc.backtrack_getrandbits(256)</span><br><span class="line">    m=rc.backtrack_getrandbits(256)</span><br><span class="line">    s=r.recvuntil(b&#x27;m: &#x27;)</span><br><span class="line">    r.sendline(str(m).encode())</span><br><span class="line">    s=r.recvuntil(b&#x27;sinature = &#x27;)</span><br><span class="line">    sig=r.recvuntil(b&#x27;\n&#x27;)[:-1]</span><br><span class="line">    s=r.recvuntil(b&#x27;signatures: &#x27;)</span><br><span class="line">    sig=b&quot;[&#x27;&quot;+sig+b&quot;&#x27;]&quot;</span><br><span class="line">    r.sendline(sig)</span><br><span class="line">    flag=r.recv()</span><br><span class="line">    if(b&#x27;&#125;&#x27; in flag):</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br><span class="line">    r.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>经过测试，发现对于同样的密钥和同样的明文，签名后的签名值是一样的，所以对于最后那个点，对于任意的num如何构造出num种签名仍然未知，各位师傅可以尝试一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/14/2025-ciscn/" data-id="cm5xgh5qi0000n4wog10l2e8m" data-title="2025-ciscn" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/01/14/blog%E6%95%99%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">blog教程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/01/14/2025-ciscn/">2025-ciscn</a>
          </li>
        
          <li>
            <a href="/2025/01/14/blog%E6%95%99%E7%A8%8B/">blog教程</a>
          </li>
        
          <li>
            <a href="/2025/01/14/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>